#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Иванов Ф.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Какие задачи удобным образом решаются методом поиска в пространстве состояний? 
Почему Prolog оказывается удобным языком для решения таких задач?

Поиск в пространстве состоаний — группа математических методов, предназначенных для решения задач искусственного интеллекта.

Методы поиска в пространстве состояний осуществляют последовательный просмотр конфигураций или состояний задачи с целью обнаружения целевого состояния, имеющего заданные характеристики или удовлетворяющего некоторому критерию.

Лучше всего метод поиска в пространстве состояний работает с задачами, в которых, очевидно, можно определить это пространство, а также начальные и конечные состояния, переходы от одного состояния к другому. Таким образом, это те задачи, которые можно свести к поиску решений в графе.

Что касается Prolog то, в этом языке очень удобно задавать состояния в виде предикатов. Сам Prolog использует один из методов поиска - поиск в глубину. Это делает использование данного метода простым и естественным, хоть и не оптимальным.

## Задание

3. Железнодорожный сортировочный узел устроен так, как показано на рисунке. На левой стороне собрано некоторое число вагонов двух типов (черные и белые), обоих типов по n штук., в произвольном порядке. Тупик вмещает все 2n вагонов. Пользуясь тремя сортировочными операциями (слева в тупик, из тупика направо, слева направо, минуя тупик), собрать вагоны на левой стороне, так, чтобы типы чередовались. Для решения задачи достаточно 3n-1 сортировочных операций.

## Принцип решения

Изначально состояние описывается пользователем. Пользователь составляет список из черных и белых вагонов.

Всего у нас 3 перехода:
1. сдвиг вагона слева в тупик,
2. из тупика направо,
3. слева направо.

Я использовал следующие алгоритмы поиска - поиск в глубину, в ширину, в глубину с ограничением, в глубину с итеративным погружением.
Для каждого из них реализовано по два предиката - рабочий и оберточный - нужен для создания понятного интерфейса (чтоб скрыть "страшную реализацию").

В глубину:

Предикат-обертка. Вызывает вспомогательный предикат goal, для получения конечного состояния и рабочий предикат dpath1.
```prolog
dpath(X, R) :-
    goal(X, G),
    dpath1([[X, [], []]], [[], [], G], R1),
    reverse(R1, R).
```
 
Рабочий предикат. Рекурсивно вызывает вспомогательный предикат prolong, пытающийся продлить очередной путь решения.
```prolog
dpath1([H | T], H, [H | T]).
dpath1(P, G, R) :-
   prolong(P, P1),
   dpath1(P1, G, R).
```

В ширину:

Предикат-обертка. Использует вспомогательный предикат extra, необходимый для походового вывода решения.
```prolog
wpath(S, R) :-
   goal(S, G),
   wpath1([[[S, [], []]]], [[], [], G], R1),
   !,
   reverse(R1, R2),
   extra(R2, R).
```
 
Рабочий предикат. Использует вспомогательный предикат mfindall, который отличается от стандартного лишь выводом пустого списка, а не "false" в случае отсутствия решений.
```prolog
wpath1([[H | T] | _], H, [H | T]).
wpath1([H | Qin], G, R) :-
   mfindall(H, L),
   append(Qin, L, Qout),
   wpath1(Qout, G, R).
```

В глубину с ограничением глубины:

Предикат-обертка. Находит количество вагонов и использует количество 3n - 1 в качестве ограничителя.
```prolog
dcpath(X, R) :-
    goal(X, G),
    length(G, C1),
    C is (3 * C1 / 2) - 1,
    dcpath1([[X, [], []]], [[], [], G], R1, C), !,
    reverse(R1, R2),
    extra(R2, R).
```
 

В глубину с итеративным погружением:

Предикат-обертка. Как видно, поиск с итеративным погружением использует рабочий предикат поиска с ограничением глубины, однако каждый раз передает ему новое число, которое генерируется вспомогательным предикатом int.
```prolog
dipath(X, R) :- 
    goal(X, G),
    int(CC),
    dcpath1([[X, [], []]], [[], [], G], R1, CC), !,
    reverse(R1, R2), 
    extra(R2, R).
```

Рабочий предикат. Выполняет поиск в глубину до тех пор, пока длина решения не превышает ограничитель.
```prolog
dcpath1([H | T], H, [H | T], _).
dcpath1(P, G, R, C) :-
    C > 0,
    prolong(P, P1), 
    C1 is C - 1,
    dcpath1(P1, G, R, C1).
```

## Результаты

| Алгоритм поиска |  Длина найденного первым пути  |              Тест                 |
|-----------------|--------------------------------|-----------------------------------|
| В глубину       |12                              |w, w, b, w, b, w, b, b|
| В ширину        |12                              |w, w, w, w, b, b, b, b|
| ID              |12                              |b, w, b, w, b, w, w, b|
| С ограничением  |12                              |w, w, b, b, b, w, b, w|
||||
| В глубину       |24                              |b, b, w, w, w, b, w, w, b, b, w, b, b, b, b, w, w, w|
| В ширину        |(переполнен стек)                              |b, b, w, w, w, b, w, w, b, b, w, b, b, b, b, w, w, w|
| ID              |24                              |b, b, w, w, w, b, w, w, b, b, w, b, b, b, b, w, w, w|
| С ограничением  |24                              |b, b, w, w, w, b, w, w, b, b, w, b, b, b, b, w, w, w|

Как видно, все виды поиска, включая поиск в глубину, всегда первым выдают кратчайший результат. Это связано с тем, что предикататы смены состояния в предикате prolong расположены в наиболее оптимальном порядке. Кроме того, при достаточно больших тестах поиск в ширину перестает работать по причине переполнения стэка памяти.

Пример поиска в ширину:
```prolog
?- wpath([w, w, w, w, b, b, b, b], R), write(R).
[[w,w,w,w,b,b,b,b],[],[]]
R = [[w, w, w, w, b, b, b, b], [], []] ;
[[w,w,w,b,b,b,b],[],[w]]
R = [[w, w, w, b, b, b, b], [], [w]] ;
[[w,w,b,b,b,b],[w],[w]]
R = [[w, w, b, b, b, b], [w], [w]] ;
[[w,b,b,b,b],[w,w],[w]]
R = [[w, b, b, b, b], [w, w], [w]] ;
[[b,b,b,b],[w,w,w],[w]]
R = [[b, b, b, b], [w, w, w], [w]] ;
[[b,b,b],[w,w,w],[b,w]]
R = [[b, b, b], [w, w, w], [b, w]] ;
[[b,b,b],[w,w],[w,b,w]]
R = [[b, b, b], [w, w], [w, b, w]] ;
[[b,b],[w,w],[b,w,b,w]]
R = [[b, b], [w, w], [b, w, b, w]] ;
[[b,b],[w],[w,b,w,b,w]]
R = [[b, b], [w], [w, b, w, b, w]] ;
[[b],[w],[b,w,b,w,b,w]]
R = [[b], [w], [b, w, b, w, b, w]] ;
[[b],[],[w,b,w,b,w,b,w]]
R = [[b], [], [w, b, w, b, w, b|...]] ;
[[],[],[b,w,b,w,b,w,b,w]]
R = [[], [], [b, w, b, w, b, w|...]] ;
false.
```

## Выводы
Данная лабораторная работа научила меня нескольким вещам. Во-первых, использование предикатов-оберток существенно упрощает взаимодействие пользователя с программой и предикатов друг с другом. Во-вторых, правильно написанная программа может решать задачи на поиск в пространстве состояний даже эффективнее человека, так как способна проверять абсолютно все варианты действий. Так, например, оказалось, что у моей задачи в определенных условиях может быть несколько кратчайших решений, хотя их различия минимальны. 
В-третьих, поиск с итеративным погружением в некоторых случаях (например в моем) может быть неэффективен. Это связано с тем, что длина решения в моей задаче не может быть меньше чем 2n. Таким образом, поиск с итеративным погружением находит примерно 4n^3 - 2n^2 лишних неполных решений различной длины.




