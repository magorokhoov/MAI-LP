## Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Артамонов О.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Задача грамматического/синтаксического разбора и анализа естественных и искусственных языков является одной из самых распространенных задач, решаемых языками логического программирования. Это связано с простотой реализации процесса переборов с возвратами и с удобством взаимодействия с символьной информацией.

Логический язык программированя Пролог очень удобен для обработки текста. На Прологе можно с успехом реализовать генераторы отчетов и трансляторы языков. В Пролога по умолчанию используется перебор возможных решений (использование бэктрекинга). Т.е. решение начинается с запроса, которое разбивается на подправила, которые делятся на еще более мелкие составные части и т.д. На ней же основывается система грамматического разбора. Поэтому реализаця такого разбора на Прологе реализуется практически естественным способом. Но в основном существует два основных подхода к обработке текста — статический и лингвистический. В основе статического подхода лежит предположение, что в содержание текста определяют наиболее часто встречающиеся слова, в отличие лингвистического подхода, который основан на лингвистическом анализе (графематический, морфологический, синтаксический, семантический).
## Задание

Реализовать синтаксический анализатор арифметического выражения и вычислить его числовое значение. В выражении допустимы операции +,-,*,/, степень ^. Учитывать приоритеты операций.
```prolog
Запрос:     ?- calculate([5, ‘+’, 3, ‘^’,2], X).
Результат:  X=14.
```

## Принцип решения

Нужно отметить, что мы работаем со списком, в котором каждый элемент представляет число или операцию, поэтому и работать нужно как со списком. Находим операцию минимальную по приоритету (-, +, *, /, ^), через предикат append делим наш список на то, что было до (A) и после (B), дальше этот же предикат запускаем для A и B. Таким образом мы дойдем до операций с максимальным приоритетом, которые глубже, посчитаем их значение, вернемся и т.д., пока полностью не выйдем из рекурсии и не получим искомое число — значение исходного выражения. Если будет попытка деления на ноль, то предикат должен вернуть false.

Реализация предиката calculate:
```prolog
calculate([N], N) :- number(N).
calculate(Expr, Ans) :- append(A, [-|B], Expr), calculate(A, X), calculate(B, Y), !, Ans is X - Y.
calculate(Expr, Ans) :- append(A, [+|B], Expr), calculate(A, X), calculate(B, Y), !, Ans is X + Y.
calculate(Expr, Ans) :- append(A, [*|B], Expr), calculate(A, X), calculate(B, Y), !, Ans is X * Y.
calculate(Expr, Ans) :- append(A, [/|B], Expr), calculate(A, X), calculate(B, Y), !, Y \= 0, Ans is X / Y.
calculate(Expr, Ans) :- append(A, [^|B], Expr), calculate(A, X), calculate(B, Y), !, Ans is X ** Y.
```
## Результаты

```prolog
?- calculate([5, '^', 2, '^', 3], X).
X = 390625.

?- calculate([5, '*', 2, '^', 3, '/', 3], X).
X = 13.333333333333332.

?- calculate([5, '+', 3, '*', 2, '^', 0], X).
X = 8.

?- calculate([5, '+', 3, '*', 2, '/', 0], X).
false.

?- calculate([22, '-', 3, '+', 6, '/', 2], X).
X = 16.

?- calculate([4, '/', 4, '+', 15, '-', 5, '+', 20, '/', 2], X).
X = 1.

?- calculate([5, '^', 2, '+', 6, '^', 2], X).
X = 61.

?- calculate([2, '*', 3, '/', 2, '+', 4, '/', 2], X).
X = 5.0.
```

## Выводы

Данная лабораторная работа дает понимание, насколько Пролог мощный инструмент. Аналогичная программа на C/C++, которая могла бы воспринимать выражение и вычислять его значение заняла бы минимум 100 строк кода, при этом нам нужно будет думать о том, как это хранить и вычислять, создавать, возможно стек/дерево. И это против 6 строчек кода на Прологе, над которыми после небольшой адаптации к языку думать однозначно проще, чем над кодом императивных или объектно-ориентированных языков. Экономия ресурсов в виде времени и сил сильно заметна.

Сам слой абстракции не то, чтобы выше/ниже, он просто совсем другой, по началу сложно переключиться на этот стиль мышления. Потом оказывается, что это довольно несложный, но 
мощный и практичный инструмент. Пролог предлагает совершенно иные возможности для написания программ, нежели популярные императивные и ооп языки, но это не заменяет их, тк все же Пролог хорош для решения конкретного класса задач: логических задач, поиска в пространстве состояний, обработка текстов и как для классического подхода к изучению искусственного интеллекта.